const express = require('express');
const cors = require('cors');
const axios = require('axios');
const http = require('http');
const https = require('https');
const url = require('url');
const rateLimit = require('express-rate-limit');
const slowDown = require('express-slow-down');
const helmet = require('helmet');
const { body, validationResult } = require('express-validator');
const morgan = require('morgan');

const app = express();
const PORT = process.env.PORT || 3000;

// ====== CONFIGURA√á√ïES DE SEGURAN√áA ======

// Helmet - Headers de seguran√ßa
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      scriptSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      imgSrc: ["'self'", "data:", "https:"],
    },
  },
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  }
}));

// Rate Limiting - 100 requests por 10 minutos por IP
const authLimiter = rateLimit({
  windowMs: 10 * 60 * 1000, // 10 minutos
  max: 100, // limite de 100 requests por windowMs por IP
  message: {
    error: 'Muitas tentativas de autentica√ß√£o',
    message: 'Limite de 100 requisi√ß√µes por 10 minutos excedido. Tente novamente mais tarde.',
    retryAfter: Math.ceil(10 * 60 / 60) + ' minutos'
  },
  standardHeaders: true,
  legacyHeaders: false,
  // Cabe√ßalhos personalizados para monitoramento
  keyGenerator: (req) => {
    return req.ip + ':' + (req.headers['user-agent'] || 'unknown');
  },
  skip: (req) => {
    // Skip para IPs locais em desenvolvimento
    if (process.env.NODE_ENV !== 'production') {
      return req.ip === '127.0.0.1' || req.ip === '::1';
    }
    return false;
  }
});

// Speed Limiting - Desacelera requests consecutivos
const speedLimiter = slowDown({
  windowMs: 1 * 60 * 1000, // 1 minuto
  delayAfter: 5, // allow 5 requests per windowMs without delay
  delayMs: 500, // add 500ms delay per request after delayAfter
  maxDelayMs: 10000, // max delay of 10 seconds
});

// Logging com Morgan
app.use(morgan('combined', {
  // Log apenas requests suspeitos ou com erro
  skip: function (req, res) {
    return res.statusCode < 400 && process.env.NODE_ENV === 'production';
  }
}));

// CORS aberto para permitir qualquer origem
app.use(cors({
  origin: true, // Permite qualquer origem
  methods: ['GET', 'POST', 'PUT', 'DELETE'],
  allowedHeaders: ['Content-Type', 'user', 'key', 'api-token'],
  credentials: false,
  maxAge: 86400 // Cache preflight por 24h
}));
app.use(express.json({ limit: '10mb' })); // Limite de payload
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Aplicar rate limiting em todas as rotas
app.use(authLimiter);
app.use(speedLimiter);

// ====== ENDPOINT DE TESTE ISOLADO (SEM VALIDA√á√ÉO) ======
app.get('/api/test', async (req, res) => {
  try {
    console.log(`üß™ Endpoint de teste /api/test chamado - testando Sentus diretamente`);
    
    const result = await fetch('https://www.sentus.inf.br/v1000/auth', {
      method: 'POST',
      headers: {
        'user': 'dados@rayalimentos',
        'key': 'QTlbWzGkSrDWCazeEK+bLA=='
      }
    });

    const text = await result.text();
    
    console.log(`üìä Resultado do teste: Status ${result.status}`);
    
    return res.status(200).json({
      message: 'Teste isolado de conectividade com Sentus',
      success: result.status === 200,
      sentusResponse: {
        status: result.status,
        headers: Object.fromEntries(result.headers.entries()),
        body: text
      },
      timestamp: new Date().toISOString()
    });
    
  } catch (err) {
    console.error(`‚ùå Erro no teste isolado:`, err);
    
    return res.status(500).json({
      error: 'Erro no teste de conectividade',
      details: {
        name: err.name,
        message: err.message,
        code: err.code,
        stack: err.stack
      },
      timestamp: new Date().toISOString()
    });
  }
});

// Token √∫nico para autentica√ß√£o da API (configure via vari√°vel de ambiente)
const API_TOKEN = process.env.API_TOKEN || 'tkn_b8f2a9e1c5d7h3j9k4m6n2p8q1r5s7t9v2w4x6y8z1';

console.log(`üîë API Token configurado: ${API_TOKEN.substring(0, 8)}...`);

// Valida√ß√µes de entrada
const validateCredentials = [
  body('user')
    .optional()
    .isLength({ min: 3, max: 100 })
    .withMessage('User deve ter entre 3 e 100 caracteres')
    .matches(/^[a-zA-Z0-9@._-]+$/)
    .withMessage('User cont√©m caracteres inv√°lidos')
    .trim()
    .escape(),
  body('key')
    .optional()
    .isLength({ min: 10, max: 500 })
    .withMessage('Key deve ter entre 10 e 500 caracteres')
    .trim(),
  body('apiToken')
    .optional()
    .isLength({ min: 10, max: 200 })
    .withMessage('API Token deve ter entre 10 e 200 caracteres')
    .trim()
];

// Fun√ß√£o para sanitizar dados de entrada
function sanitizeInput(input) {
  if (typeof input !== 'string') return input;
  return input.trim().replace(/[<>]/g, ''); // Remove caracteres perigosos
}

// Fun√ß√£o para validar formato de credenciais
function validateCredentialFormat(user, key, apiToken) {
  // Valida√ß√µes b√°sicas de formato
  if (!user || !key || !apiToken) return false;
  if (typeof user !== 'string' || typeof key !== 'string' || typeof apiToken !== 'string') return false;
  if (user.length < 3 || user.length > 100) return false;
  if (key.length < 10 || key.length > 500) return false;
  if (apiToken.length < 10 || apiToken.length > 200) return false;
  
  // N√£o permite caracteres suspeitos
  const suspiciousChars = /[<>'";\(\)\{\}\[\]]/;
  if (suspiciousChars.test(user) || suspiciousChars.test(key) || suspiciousChars.test(apiToken)) return false;
  
  return true;
}

// Endpoint principal que recebe credenciais e retorna Bearer Token
// EXCLUINDO rotas /api/* para n√£o interferir com Vercel API routes
app.all(/^(?!\/api\/).*/, validateCredentials, async (req, res) => {
  const startTime = Date.now();
  const clientIP = req.ip || req.connection.remoteAddress;
  const userAgent = req.get('User-Agent') || 'unknown';
  
  try {
    // Valida√ß√£o de entrada
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      console.warn(`‚ö†Ô∏è  Valida√ß√£o falhou para IP ${clientIP}: ${JSON.stringify(errors.array())}`);
      return res.status(400).json({
        error: 'Dados de entrada inv√°lidos',
        message: 'Formato das credenciais est√° incorreto',
        details: errors.array()
      });
    }
    
    // Extrai e sanitiza as credenciais user, key e apiToken do body ou headers
    let user, key, apiToken;
    
    // Tenta pegar do body primeiro, depois dos headers
    if (req.body && (req.body.user || req.body.key || req.body.apiToken)) {
      user = sanitizeInput(req.body.user);
      key = sanitizeInput(req.body.key);
      apiToken = sanitizeInput(req.body.apiToken);
    } else {
      user = sanitizeInput(req.headers.user);
      key = sanitizeInput(req.headers.key);
      apiToken = sanitizeInput(req.headers['api-token']);
    }
    
    // Valida√ß√£o do token de API PRIMEIRO (mais importante)
    if (!apiToken || apiToken !== API_TOKEN) {
      console.warn(`üö® Token de API inv√°lido ou ausente de IP ${clientIP}: ${apiToken ? apiToken.substring(0, 8) + '...' : 'AUSENTE'}`);
      return res.status(401).json({
        error: 'Token de API inv√°lido',
        message: '√â necess√°rio enviar um token de API v√°lido para acessar este servi√ßo'
      });
    }
    
    // Valida√ß√£o adicional de formato das credenciais
    if (!validateCredentialFormat(user, key, apiToken)) {
      console.warn(`‚ö†Ô∏è  Credenciais com formato inv√°lido de IP ${clientIP}`);
      return res.status(400).json({
        error: 'Credenciais inv√°lidas',
        message: 'Formato das credenciais user/key/apiToken est√° incorreto'
      });
    }
    
    // Log de seguran√ßa
    console.log(`üîê Tentativa de autentica√ß√£o de IP: ${clientIP}, User-Agent: ${userAgent}, User: ${user}`);
    
    // Verifica√ß√£o adicional para poss√≠veis ataques
    if (user.includes('..') || key.includes('..') || apiToken.includes('..') ||
        user.includes('javascript:') || key.includes('javascript:') || apiToken.includes('javascript:')) {
      console.error(`üö® Poss√≠vel tentativa de ataque de IP ${clientIP}: ${user}`);
      return res.status(400).json({
        error: 'Credenciais suspeitas',
        message: 'Conte√∫do das credenciais n√£o √© permitido'
      });
    }

    console.log(`üîê Fazendo autentica√ß√£o para user: ${user}`);

    console.log(`üì§ Enviando requisi√ß√£o NATIVA para Sentus com headers: user=${user}, key=${key.substring(0,5)}...`);
    
    // Vamos tentar ambas as URLs e ver qual funciona
    const httpsUrl = 'https://www.sentus.inf.br/v1000/auth';
    const httpUrl = 'http://www.sentus.inf.br/v1000/auth';
    
    // Primeiro tentamos detectar se o servidor responde
    console.log(`üß™ Testando conectividade com servidor Sentus...`);
    
    let authUrl = httpsUrl; // Come√ßamos com HTTPS
    console.log(`üåê Tentando primeiro: ${authUrl}`);
    
    // Usando HTTP nativo para controle TOTAL da requisi√ß√£o
    const authResponse = await new Promise((resolve, reject) => {
      const parsedUrl = url.parse(authUrl);
      
      const options = {
        hostname: parsedUrl.hostname,
        port: parsedUrl.port || (parsedUrl.protocol === 'https:' ? 443 : 80),
        path: parsedUrl.path,
        method: 'POST',
        headers: {
          'user': user,
          'key': key
          // APENAS esses dois headers, NADA mais
        }
      };
      
      // Usa https ou http baseado na URL
      const requestModule = parsedUrl.protocol === 'https:' ? https : http;
      const req = requestModule.request(options, (response) => {
        let data = '';
        
        response.on('data', (chunk) => {
          data += chunk;
        });
        
        response.on('end', () => {
          console.log(`üì• Resposta recebida: Status ${response.statusCode}`);
          console.log(`üì• Headers da resposta:`, response.headers);
          
          resolve({
            status: response.statusCode,
            headers: response.headers,
            data: data
          });
        });
      });
      
      req.on('error', (error) => {
        console.error(`‚ùå Erro na requisi√ß√£o (${authUrl}):`, error.message);
        console.error(`‚ùå C√≥digo do erro:`, error.code);
        console.error(`‚ùå Stack trace:`, error.stack);
        
        // Informa√ß√µes detalhadas para debug
        console.error(`‚ùå Detalhes do erro:`, {
          code: error.code,
          errno: error.errno,
          syscall: error.syscall,
          hostname: error.hostname,
          port: error.port
        });
        
        reject(error);
      });
      
      req.setTimeout(10000, () => {
        req.destroy();
        reject(new Error('Timeout'));
      });
      
      // N√£o enviamos NENHUM body
      req.end();
    });

    // Verifica se a requisi√ß√£o foi bem-sucedida
    if (authResponse.status !== 200) {
      return res.status(authResponse.status).json({
        error: 'Falha na autentica√ß√£o',
        message: `Servidor de autentica√ß√£o retornou erro: ${authResponse.status}`,
        details: authResponse.data
      });
    }

    // Extrai o header Authorization da resposta
    const authHeader = authResponse.headers.authorization;
    
    if (!authHeader) {
      return res.status(401).json({
        error: 'Token n√£o recebido',
        message: 'O servidor de autentica√ß√£o n√£o retornou um token Authorization'
      });
    }

    // Verifica se √© um Bearer Token
    if (!authHeader.startsWith('Bearer ')) {
      return res.status(401).json({
        error: 'Formato de token inv√°lido',
        message: 'Token recebido n√£o est√° no formato Bearer'
      });
    }

    // Extrai apenas o token (remove "Bearer ")
    const bearerToken = authHeader.substring(7);

    const responseTime = Date.now() - startTime;
    console.log(`‚úÖ Token obtido com sucesso para user: ${user} (IP: ${clientIP}) em ${responseTime}ms`);

    // Retorna o Bearer token (sem expor dados sens√≠veis)
    res.json({
      success: true,
      message: 'Autentica√ß√£o realizada com sucesso',
      bearerToken: bearerToken,
      authInfo: {
        user: user,
        timestamp: new Date().toISOString(),
        requestMethod: req.method,
        requestUrl: req.url,
        responseTime: `${responseTime}ms`
      }
    });

  } catch (error) {
    const responseTime = Date.now() - startTime;
    console.error(`‚ùå Erro na autentica√ß√£o para IP ${clientIP}: ${error.message} (tempo: ${responseTime}ms)`);
    
    // Log detalhado para debugging em desenvolvimento
    if (process.env.NODE_ENV !== 'production') {
      console.error('Stack trace:', error.stack);
    }
    
    if (error.code === 'ECONNREFUSED' || error.code === 'ETIMEDOUT' || error.message === 'Timeout') {
      // Erro de conex√£o
      return res.status(503).json({
        error: 'Servidor de autentica√ß√£o indispon√≠vel',
        message: 'N√£o foi poss√≠vel conectar ao servidor de autentica√ß√£o',
        timestamp: new Date().toISOString()
      });
    } else {
      // Erro interno - n√£o expor detalhes em produ√ß√£o
      const errorMessage = process.env.NODE_ENV === 'production' 
        ? 'Erro interno do servidor' 
        : error.message;
        
      return res.status(500).json({
        error: 'Erro interno do servidor',
        message: errorMessage,
        timestamp: new Date().toISOString()
      });
    }
  }
});

// ====== ENDPOINT DE TESTE PARA DEBUG ======
app.get('/test-sentus', async (req, res) => {
  try {
    console.log(`üß™ Endpoint de teste chamado - testando conectividade com Sentus`);
    
    const result = await fetch('https://www.sentus.inf.br/v1000/auth', {
      method: 'POST',
      headers: {
        'user': 'teste@rayalimentos',
        'key': 'chaveFakeParaTeste123'
      }
    });

    const text = await result.text();
    
    console.log(`üìä Resultado do teste: Status ${result.status}`);
    
    return res.status(200).json({
      message: 'Teste de conectividade com Sentus',
      sentusResponse: {
        status: result.status,
        headers: Object.fromEntries(result.headers.entries()),
        body: text
      },
      timestamp: new Date().toISOString()
    });
    
  } catch (err) {
    console.error(`‚ùå Erro no teste:`, err);
    
    return res.status(500).json({
      error: 'Erro no teste de conectividade',
      details: {
        message: err.message,
        stack: err.stack,
        name: err.name,
        cause: err.cause
      },
      timestamp: new Date().toISOString()
    });
  }
});

// Inicia o servidor
app.listen(PORT, () => {
  console.log(`üöÄ Servidor rodando na porta ${PORT}`);
  console.log(`üìç URL: http://localhost:${PORT}`);
  console.log('üí° Envie uma requisi√ß√£o com Bearer Token no header Authorization');
}); 